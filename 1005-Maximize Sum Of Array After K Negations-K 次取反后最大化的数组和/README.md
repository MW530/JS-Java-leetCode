本题也是一个最优化问题，可以使用贪心的思路。即将全局最优分解为局部最优。所以这里的反转，要使全局数最大。则有一个简单的思路：如果是负数，则可以将其反转，并且从最小的负数开始反转。而如果数组中只有正数，则如果k为偶数，那就不反转（反转两次=不反转）；如果是奇数，就反转最小的正数一次（其他的一个大偶数=不反转）。

所以算法上来讲-就是先遍历一次将负数从小到大反转，然后考察k，如果k为0了，则直接返回数组的和。如果不为0，则将其转化为0/1（这种情况nums中全部为正数），然后将最小的正数反转，再返回数组的和。