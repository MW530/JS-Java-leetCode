本题是一道[NP完全问题](https://baike.baidu.com/item/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98)，没办法在多项式时间内解决。

但是可以转化为0-1背包问题。即从给定数组中取一定数量的元素组成所有元素和的一半。

使用动态规划，就必须看动态规划的4个步骤：

## 确定dp数组的含义

这里都选择滚动数组，因为节约空间

这里有两种定义方法：

- 定义当前dp数组元素即为能放下的最大值。
- 定义当前dp数组元素为是否能刚好容纳该位置大小的元素。

由于第二种数组类型为bool，更小，所以选第二种。dp的容量由于背包的最大容量就是元素和的一半，所以容量就为`sum/2 + 1`。

## 确定递归公式

与01背包思想一致，当前位置能否刚好容纳，取决于当前物品放与不放。

- 不放：则当前位置的值刚好等于`dp[j]`（即不包含该元素的同一个背包容量位置）。
- 放：则看去掉该物品大小之前的位置是否能够刚好容纳，`dp[j - nums[i]]`。（换句话说，当前位置能容纳的必要条件是去掉该物品大小后的位置，刚好能容纳）

这两种情况下，只要有一种为true，则就为true。因此是或的关系。

综上，递归公式为：`dp[j] |= dp[j - nums[i]]`

## 初始化dp

从dp的定义来看，在0的位置，即背包容量为0，只有一个物品时，能否刚好装满背包。显然，刚好是0，则一定被装满了，所以`dp[0]=true`

## 确定遍历顺序

由于要使用滚动数组，所以与0-1背包一致，必须先遍历物品，在遍历容量，并且容量必须从大到小的遍历。



# 0-1背包问题的描述

这种类似的问题，必须抽象出其本质，然后去拟合已有的问题。比如这一道题，本质上是要从数组中拿出一定数量的元素，使之刚好能够达到所有元素大小的一半。这里有几个关键特征：

- 元素只能使用一次。
- 元素不可分。
- 要求刚好达到某一个数。

这几个特征与0-1背包中的元素只能使用一次，元素不可分，对应背包容量的最大值完全一致，所以可以套用到0-1背包问题上。

## 