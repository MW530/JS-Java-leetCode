本题是一道较为复杂的回溯问题，其难点主要在以下几点：

- 一个起始点可能飞向多个不同的目的地。
- 返回的路线必须按照字典排序返回最小的行程组合。

所以这里一般先对tickets对象重新整理，得到一个`[出发点-[目的地]]`的数据结构。

值得注意的是`[目的地]`必须按照字典排序。方便后期的操作。

在本例的Java中，使用了优先队列，就避免了手动排序。

而js代码中，就只能统计后再进行排序。

还有一点是给出的例子中可能存在出发地和目的地相反的情况，此时如果不进行特殊处理，则会出现死循环的情况。所以必须在递归之前去除该目的地，等递归结束再加回来。才能避免死循环。